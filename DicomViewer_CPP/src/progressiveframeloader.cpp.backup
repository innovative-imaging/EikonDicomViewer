#include "progressiveframeloader.h"
#include <QtCore/QDebug>
#include <QtCore/QMutexLocker>
#include <QtGui/QImage>
#include <QtCore/QThread>

ProgressiveFrameLoader::ProgressiveFrameLoader(const QString& filePath, QObject* parent)
    : QThread(parent)
    , m_filePath(filePath)
    , m_stopped(false)
#ifdef HAVE_DCMTK
    , m_dcmFile(nullptr)
    , m_dataset(nullptr)
{
}

ProgressiveFrameLoader::~ProgressiveFrameLoader()
{
    stop();
    wait(); // Wait for thread to finish
    
#ifdef HAVE_DCMTK
    delete m_dcmFile;
    
}

void ProgressiveFrameLoader::stop()
{
    QMutexLocker locker(&m_mutex);
    m_stopped = true;
}

bool ProgressiveFrameLoader::isStopped() const
{
    QMutexLocker locker(&m_mutex);
    return m_stopped;
}

void ProgressiveFrameLoader::run()
{
    
    try {
        // Load DICOM metadata first
        if (!loadDicomMetadata()) {
            emit errorOccurred("Failed to load DICOM metadata");
            return;
        }
        
        // Emit first frame info for overlay setup
        emit firstFrameInfo(m_metadata.patientName, m_metadata.patientId, m_metadata.totalFrames);
        
        // Process frames one by one
        for (int frameIndex = 0; frameIndex < m_metadata.totalFrames; frameIndex++) {
            
            // Check if we should stop
            if (isStopped()) {
                return;
            }
            
            // Process this frame
            QPixmap framePixmap = processFrame(frameIndex);
            if (framePixmap.isNull()) {
                continue;
            }
            
            // Extract original pixel data for windowing
            QByteArray originalData = extractOriginalPixelData(frameIndex);
            
            // Emit frame ready signal
            emit frameReady(frameIndex, framePixmap, originalData);
            
            // Emit progress update
            emit loadingProgress(frameIndex + 1, m_metadata.totalFrames);
            
            // Small delay to avoid overwhelming the UI thread
            if (m_metadata.totalFrames > 10) {
                msleep(50); // 50ms delay between frames for large datasets
            } else {
                msleep(10); // Shorter delay for smaller datasets
            }
        }
        
        // All frames processed successfully
        if (!isStopped()) {
            emit allFramesLoaded(m_metadata.totalFrames);
        }
        
    } catch (const std::exception& e) {
        emit errorOccurred(QString("Error loading frames: %1").arg(e.what()));
    } catch (...) {
        emit errorOccurred("Unknown error occurred while loading frames");
    }
}

bool ProgressiveFrameLoader::loadDicomMetadata()
{
#ifdef HAVE_DCMTK
    try {
        // Create and load DICOM file
        m_dcmFile = new DcmFileFormat();
        OFCondition status = m_dcmFile->loadFile(m_filePath.toLocal8Bit().constData());
        
        if (status.bad()) {
            return false;
        }
        
        m_dataset = m_dcmFile->getDataset();
        if (!m_dataset) {
            return false;
        }
        
        // Extract basic metadata
        OFString patientName, patientId, studyDesc, seriesDesc;
        m_dataset->findAndGetOFString(DCM_PatientName, patientName);
        m_dataset->findAndGetOFString(DCM_PatientID, patientId);
        m_dataset->findAndGetOFString(DCM_StudyDescription, studyDesc);
        m_dataset->findAndGetOFString(DCM_SeriesDescription, seriesDesc);
        
        m_metadata.patientName = QString::fromStdString(patientName.c_str());
        m_metadata.patientId = QString::fromStdString(patientId.c_str());
        m_metadata.studyDescription = QString::fromStdString(studyDesc.c_str());
        m_metadata.seriesDescription = QString::fromStdString(seriesDesc.c_str());
        
        // Get image dimensions
        Uint16 rows, columns;
        if (m_dataset->findAndGetUint16(DCM_Rows, rows).good()) {
            m_metadata.imageHeight = rows;
        }
        if (m_dataset->findAndGetUint16(DCM_Columns, columns).good()) {
            m_metadata.imageWidth = columns;
        }
        
        // Get window/level values
        OFString windowCenter, windowWidth;
        if (m_dataset->findAndGetOFString(DCM_WindowCenter, windowCenter).good()) {
            m_metadata.windowCenter = QString::fromStdString(windowCenter.c_str()).toDouble();
        }
        if (m_dataset->findAndGetOFString(DCM_WindowWidth, windowWidth).good()) {
            m_metadata.windowWidth = QString::fromStdString(windowWidth.c_str()).toDouble();
        }
        
        // Get number of frames
        OFString numberOfFrames;
        if (m_dataset->findAndGetOFString(DCM_NumberOfFrames, numberOfFrames).good()) {
            m_metadata.totalFrames = QString::fromStdString(numberOfFrames.c_str()).toInt();
        } else {
            m_metadata.totalFrames = 1; // Single frame
        }
        
        
        return true;
        
    } catch (const std::exception& e) {
        return false;
    } catch (...) {
        return false;
    }
#else
    return false;
}

QPixmap ProgressiveFrameLoader::processFrame(int frameIndex)
{
#ifdef HAVE_DCMTK
    try {
        // Create DicomImage for this specific frame
        DicomImage* dicomImage = new DicomImage(m_filePath.toLocal8Bit().constData(), CIF_AcrNemaCompatibility);
        
        if (!dicomImage || dicomImage->getStatus() != EIS_Normal) {
            delete dicomImage;
            return QPixmap();
        }
        
        // For multiframe images, select the specific frame
        if (m_metadata.totalFrames > 1) {
            // Use the constructor with frame selection instead of createScaledImage
            delete dicomImage;
            dicomImage = new DicomImage(m_filePath.toLocal8Bit().constData(), CIF_AcrNemaCompatibility, frameIndex);
            
            if (!dicomImage || dicomImage->getStatus() != EIS_Normal) {
                delete dicomImage;
                return QPixmap();
            }
        }
        
        // Apply window/level if available
        if (m_metadata.windowCenter != 0.0 && m_metadata.windowWidth != 0.0) {
            dicomImage->setWindow(m_metadata.windowCenter, m_metadata.windowWidth);
        }
        
        // Convert to 8-bit for display
        const void* pixelData = dicomImage->getOutputData(8 /* bits per sample */);
        if (!pixelData) {
            delete dicomImage;
            return QPixmap();
        }
        
        // Create QImage from pixel data
        QImage qImage((const uchar*)pixelData, 
                     m_metadata.imageWidth, 
                     m_metadata.imageHeight, 
                     QImage::Format_Grayscale8);
        
        // Convert to RGB format for better compatibility
        QImage rgbImage = qImage.convertToFormat(QImage::Format_RGB888);
        
        // Create pixmap
        QPixmap pixmap = QPixmap::fromImage(rgbImage);
        
        delete dicomImage;
        return pixmap;
        
    } catch (const std::exception& e) {
        return QPixmap();
    } catch (...) {
        return QPixmap();
    }
#else
    Q_UNUSED(frameIndex)
    return QPixmap();
}

QByteArray ProgressiveFrameLoader::extractOriginalPixelData(int frameIndex)
{
#ifdef HAVE_DCMTK
    try {
        // Create DicomImage to get raw pixel data
        DicomImage* dicomImage = new DicomImage(m_filePath.toLocal8Bit().constData(), CIF_AcrNemaCompatibility);
        
        if (!dicomImage || dicomImage->getStatus() != EIS_Normal) {
            delete dicomImage;
            return QByteArray();
        }
        
        // For multiframe images, select the specific frame
        if (m_metadata.totalFrames > 1) {
            // Use the constructor with frame selection instead of createScaledImage
            delete dicomImage;
            dicomImage = new DicomImage(m_filePath.toLocal8Bit().constData(), CIF_AcrNemaCompatibility, frameIndex);
            
            if (!dicomImage || dicomImage->getStatus() != EIS_Normal) {
                delete dicomImage;
                return QByteArray();
            }
        }
        
        // Get original pixel data (16-bit or whatever the original depth is)
        const void* rawPixelData = dicomImage->getOutputData(16 /* preserve original depth */);
        if (!rawPixelData) {
            delete dicomImage;
            return QByteArray();
        }
        
        // Calculate size and copy data
        size_t dataSize = m_metadata.imageWidth * m_metadata.imageHeight * sizeof(Uint16);
        QByteArray originalData(static_cast<const char*>(rawPixelData), dataSize);
        
        delete dicomImage;
        return originalData;
        
    } catch (const std::exception& e) {
        return QByteArray();
    } catch (...) {
        return QByteArray();
    }
#else
    Q_UNUSED(frameIndex)
    return QByteArray();
}


